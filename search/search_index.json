{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"practica1/","title":"Practica 1","text":"<p>Sitio de Juan</p>"},{"location":"practica3.1/","title":"Practica-IAW-3.1: Instalaci\u00f3n de Moodle con Ansible","text":""},{"location":"practica3.1/#estructura-de-la-practica","title":"Estructura de la Pr\u00e1ctica","text":""},{"location":"practica3.1/#objetivo-de-la-practica","title":"Objetivo de la Pr\u00e1ctica","text":"<p>El objetivo de esta pr\u00e1ctica es automatizar la instalaci\u00f3n y configuraci\u00f3n de Moodle en AWS utilizando Ansible. Para ello, se desplegar\u00e1 una arquitectura de dos niveles, con:</p> <ol> <li>Un servidor frontend: Donde llevaremos a cabo la instalaci\u00f3n de Apache, PHP y Moodle.</li> <li>Un servidor backend: Incluyendo la instalaci\u00f3n de MySQL c\u00f3mo base de datos.</li> <li>Un nodo de control (d\u00f3nde se ejecuta Ansible): Desde aqu\u00ed se automatizar\u00e1 la instalaci\u00f3n y configuraci\u00f3n de las instancias EC2.</li> </ol>"},{"location":"practica3.1/#recordatorio-de-cambio-de-la-direccion-ip-para-actualizar-el-nombre-de-dominio-nuestra-pagina-web","title":"Recordatorio de cambio de la direcci\u00f3n IP para actualizar el nombre de dominio nuestra p\u00e1gina web","text":"<p>[!IMPORTANT] Tal y c\u00f3mo hemos visto en las pr\u00e1cticas anteriores, hemos creado un dominio para nuestra p\u00e1gina web, de forma que, est\u00e9 asociada a la direcci\u00f3n IP de nuestra m\u00e1quina, por lo que nos dirigimos a la p\u00e1gina NO-IP y actualizamos la direcci\u00f3n IP, el nombre no se permite cambiar, por lo que en este caso solo cambiaremos la direcci\u00f3n IP.</p> <p></p>"},{"location":"practica3.1/#proceso-de-instalacion-y-configuracion-de-moodle","title":"Proceso de instalaci\u00f3n y configuraci\u00f3n de Moodle","text":"<ul> <li><code>install_lamp_backend.yaml</code>: Este archivo playbook de Ansible tiene como objetivo configurar y desplegar un servidor MySQL en la instancia backend de AWS, automatizando su instalaci\u00f3n, configuraci\u00f3n y la creaci\u00f3n de la base de datos para Moodle.</li> </ul> <p>Contenido del archivo: </p> <pre><code>\n    - name: Configuraci\u00f3n del Servidor de Base de Datos (Backend)\n  hosts: backend\n  become: yes\n\n  vars_files:\n    - ../vars/variables.yml\n\n  tasks:\n\n    - name: Actualizar paquetes\n      apt:\n        update_cache: yes\n        upgrade: yes\n\n    - name: Instalamos MySQL Server\n      apt:\n        name: mysql-server\n        state: present\n\n    - name: Habilitamos el servicio MySQL\n      service:\n        name: mysql\n        state: started\n        enabled: yes\n\n    - name: Instalamos el m\u00f3dulo pymysql\n      apt:\n        name: python3-pymysql\n        state: present\n\n    - name: Eliminamos la base de datos por si existe\n      mysql_db:\n        name: \"{{ db.name }}\"\n        state: absent\n        login_unix_socket: /var/run/mysqld/mysqld.sock\n\n    - name: Creamos la base de datos para Moodle\n      mysql_db:\n        name: \"{{ db.name }}\"\n        state: present\n        login_unix_socket: /var/run/mysqld/mysqld.sock\n\n    - name: Creamos un usuario de la base de datos para Moodle\n      mysql_user:\n        name: \"{{ db.user }}\"\n        password: \"{{ db.password }}\"\n        priv: \"{{ db.name }}.*:ALL\"\n        host: \"{{ db.frontend_private_ip }}\"\n        state: present\n        login_unix_socket: /var/run/mysqld/mysqld.sock\n\n    - name: Permitimos conexiones remotas a MySQL\n      lineinfile:\n        path: /etc/mysql/mysql.conf.d/mysqld.cnf\n        regexp: '^bind-address'\n        line: 'bind-address = 0.0.0.0'\n\n    - name: Reiniciamos MySQL\n      service:\n        name: mysql\n        state: restarted\n\n</code></pre> <ul> <li><code>install_lamp_frontend.yaml</code>: El objetivo es configurar un servidor web Apache con PHP en una instancia EC2 de AWS, que actuar\u00e1 como capa frontend de la arquitectura de dos niveles para la instalaci\u00f3n de Moodle.</li> </ul> <p>Contenido del archivo: </p> <pre><code>\n    - name: Configuraci\u00f3n del Servidor Web (Frontend)\n  hosts: frontend\n  become: yes\n  tasks:\n    - name: Actualizamos paquetes\n      apt:\n        update_cache: yes\n        upgrade: yes\n\n    - name: Instalamos el servidor web Apache\n      apt:\n        name: apache2\n        state: present\n\n    - name: Instalamos PHP as\u00ed c\u00f3mo sus dependencias\n      apt:\n        name:\n          - php\n          - php-mysql\n          - libapache2-mod-php\n          - php-xml\n          - php-curl\n          - php-mbstring\n          - php-zip\n          - php-gd\n          - unzip\n          - php-intl\n          - php-soap\n          - php-ldap\n          - php-opcache\n          - php-cli\n        state: present\n\n    - name: Creamos el directorio de datos de moodle\n      file:\n        path: /var/www/moodledata\n        state: directory\n        owner: www-data\n        group: www-data\n        mode: '0755'\n\n    - name: Modificamos el valor max_input_vars de PHP\n      replace: \n        path: /etc/php/8.3/apache2/php.ini\n        regexp: '^;max_input_vars\\s=.*'\n        replace: max_input_vars = 5000\n\n    - name: Modificamos el valor max_input_vars de PHP\n      replace: \n        path: /etc/php/8.3/cli/php.ini\n        regexp: '^;max_input_vars\\s=.*'\n        replace: max_input_vars = 5000\n\n    - name: Modificamos el valor memory_limit de PHP\n      replace: \n        path: /etc/php/8.3/apache2/php.ini\n        regexp: '^;memory_limit\\s=.*'\n        replace: memory_limit = 256M\n\n    - name: Modificamos el valor memory_limit de PHP CLI\n      replace:\n        path: /etc/php/8.3/cli/php.ini\n        regexp: '^;memory_limits\\s=.*'\n        replace: memory_limit = 256M\n\n    - name: Modificamos el valor post_max_size de PHP\n      replace: \n        path: /etc/php/8.3/apache2/php.ini\n        regexp: '^;post_max_size\\s=.*'\n        replace: post_max_size = 128M\n\n    - name: Modificamos el valor post_max_size de PHP\n      replace: \n        path: /etc/php/8.3/cli/php.ini\n        regexp: '^;post_max_size\\s=.*'\n        replace: post_max_size = 128M\n\n    - name: Modificamos el valor upload_max_filesize de PHP\n      replace:\n        path: /etc/php/8.3/apache2/php.ini\n        regexp: '^;upload_max_filesize\\s=.*'\n        replace: upload_max_filesize = 128M\n\n    - name: Modificamos el valor upload_max_filesize de PHP\n      replace:\n        path: /etc/php/8.3/cli/php.ini\n        regexp: '^;upload_max_filesize\\s=.*'\n        replace: upload_max_filesize = 128M\n\n    - name: Modificamos el valor max_execution_time de PHP\n      replace:\n        path: /etc/php/8.3/apache2/php.ini\n        regexp: '^;max_execution_time\\s=.*'\n        replace: 'max_execution_time = 300'\n\n    - name: Modificamos el valor max_execution_time de PHP CLI\n      replace:\n        path: /etc/php/8.3/cli/php.ini\n        regexp: '^;max_execution_time\\s=.*'\n        replace: 'max_execution_time = 300'\n\n    - name: Copiamos el archivo de configuraci\u00f3n de Apache\n      copy:\n        src: ../templates/000-default.conf\n        dest: /etc/apache2/sites-available/\n        mode: 0755\n\n    - name: Habilitamos el m\u00f3dulo rewrite de Apache\n      apache2_module:\n            name: rewrite\n            state: present\n\n    - name: Reiniciamos Apache\n      service:\n        name: apache2\n        state: restarted\n\n</code></pre> <ul> <li><code>deploy.yaml</code>: Tiene como objetivo principal la instalaci\u00f3n y configuraci\u00f3n autom\u00e1tica de Moodle en un servidor frontend utilizando Ansible. </li> </ul> <p>Contenido del archivo: </p> <pre><code>\n    - name: Instalaci\u00f3n de Moodle\n  hosts: frontend\n  become: yes\n  vars_files:\n    - ../vars/variables.yml\n\n  tasks:\n\n    - name: Eliminamos archivos previos en el directorio de moodle\n      file:\n          path: /var/www/html/*\n          state: absent\n\n    - name: Descargamos Moodle\n      get_url:\n        url: \"https://github.com/moodle/moodle/archive/refs/tags/v4.3.1.zip \"\n        dest: \"/tmp\"\n\n    - name: Instalamos el descomprimidor unzip\n      apt: \n        name: unzip\n        state: present\n\n    - name: Extraemos Moodle\n      unarchive:\n        src: /tmp/moodle-4.3.1.zip\n        dest: /tmp\n        remote_src: yes\n\n    - name: Copiamos moodle a su directorio /var/www/html\n      copy:\n        src: /tmp/moodle-4.3.1/\n        dest: /var/www/html\n        remote_src: true\n        force: yes\n\n    - name: Configuramos permisos de Moodle\n      file:\n        path: /var/www/html\n        owner: www-data\n        group: www-data\n        recurse: yes\n        mode: \"0755\"\n      loop:\n        - /var/www/html\n        - /var/www/html/moodledata\n\n    - name: Instalamos Moodle desde CLI\n      command:\n        sudo -u www-data php /var/www/html/admin/cli/install.php \\\n        --wwwroot={{ moodle.wwwroot }} \\\n        --dataroot={{ moodle.data_directory }} \\\n        --dbtype={{ moodle.type }} \\\n        --dbhost={{ db.host }} \\\n        --dbname={{ db.name }} \\\n        --dbuser={{ db.user }} \\\n        --dbpass={{ db.password }} \\\n        --fullname=\"{{ moodle.fullname }}\" \\\n        --shortname=\"{{ moodle.shortname }}\" \\\n        --summary=\"{{ moodle.summary }}\" \\\n        --adminuser={{ moodle.admin_user }} \\\n        --adminpass={{ moodle.admin_pass }} \\\n        --adminemail={{ moodle.admin_email }} \\\n        --non-interactive \\\n        --agree-license\n\n      args:\n        chdir: /var/www/html\n\n    - name: Reiniciamos Apache\n      service:\n        name: apache2\n        state: restarted\n\n\n</code></pre> <p>Y por \u00faltimo, configuraremos letsencrypt para que nuestra p\u00e1gina web sea HTTPS.</p> <ul> <li><code>deploy.yaml</code>: Tiene como objetivo principal la instalaci\u00f3n y configuraci\u00f3n autom\u00e1tica de Moodle en un servidor frontend utilizando Ansible. </li> </ul> <p>Contenido del archivo: </p> <pre><code>\n- name: Configuraci\u00f3n de HTTPS con Let's Encrypt\n  hosts: frontend\n  become: yes\n  vars_files:\n    - ../vars/variables.yml\n\n  tasks:\n\n    - name: Desinstalamos instalaciones previas de Certbot\n      apt:\n        name: certbot\n        state: absent\n\n    - name: Instalamos Certbot con el gestor de paquetes snap\n      snap:\n        name: certbot\n        classic: yes\n        state: present\n\n    - name: Solicitamos y configuramos el certificado SSL/TLS a Let's Encrypt con certbot\n      command:\n          certbot --apache \\\n          -m {{ certbot.email }} \\\n          --agree-tos \\\n          --no-eff-email \\\n          --non-interactive \\\n          -d {{ certbot.domain }}\n\n    - name: Reiniciamos Apache para aplicar los cambios\n      service:\n        name: apache2\n        state: restarted\n</code></pre> <p>[!NOTE] A\u00f1adiremos las l\u00edneas \"ServerSignature Off\" y \"ServerTokens Prod\" en el archivo 000-default.conf para mejorar la seguridad de nuestro servidor apache.</p> <p>Explicado el motivo, el archivo 000-default.conf quedar\u00e1 de la siguiente manera:</p> <p></p> <p>[!IMPORTANT] C\u00f3mo hemos podido observar anteriormente, tenemos una carpeta en nuestra estructura llamada \"inventory\", esta carpeta incluye las direcciones IPs de las m\u00e1quinas a controlar (frontend y backend), usuario de ansible as\u00ed c\u00f3mo la clave a usar para la conexi\u00f3n con las mismas. Cabe recordar tras adjuntar al repo la clave, ejecutar el comando \"chmod 400 vockey.pem\" para que no de problemas la conexi\u00f3n y tenga los permisos necesarios</p> <p></p> <p>Tambi\u00e9n tenemos un archivo llamado \"main.yaml\", d\u00f3nde le especificamos a Ansible los archivos que deseamos ejecutar sobre los dispositivos a manejar.</p> <p></p>"},{"location":"practica3.1/#variables-incluidas-en-el-archivo-envars","title":"Variables incluidas en el archivo \".envars\"","text":""},{"location":"practica3.1/#comprobaciones-generales","title":"Comprobaciones generales","text":"<p>Una vez redactados los comandos \u00fatiles, probaremos la ejecuci\u00f3n del script de modo que se ejecute sin errores.</p> <p></p> <p></p> <p></p> <p>Y para finalizar, ejecutaremos el archivo \"setup letsencrypt\"</p> <p></p>"},{"location":"practica3.1/#sitio-moodle","title":"Sitio Moodle","text":"<p>Una vez ejecutado todos los scripts con \u00e9xito, introduciremos el nombre de nuestro dominio y cargar\u00e1 la p\u00e1gina de nuestro sitio moodle funcionando</p> <p></p> <p></p>"},{"location":"practica4.5/","title":"Practica-IAW-4.5: Terraform en AWS","text":"<p>En esta pr\u00e1ctica, crearemos nuestra Infraestructura creada en la pr\u00e1ctica 1.11 con terraform en AWS, de forma que sea totalmente automatizada, englobando la creaci\u00f3n de instancias, grupos de seguridad as\u00ed c\u00f3mo IPs el\u00e1sticas, posteriormente, procederemos a su eliminaci\u00f3n.</p>"},{"location":"practica4.5/#creacion-de-nuestra-infraestructura","title":"Creaci\u00f3n de Nuestra InfraEstructura","text":"<pre><code>\n    provider \"aws\" {\n    region = var.region\n    }\n\n    # Creamos el grupo de seguridad del frontend\n    resource \"aws_security_group\" \"frontend\" {\n    name        = var.SECURITY_GROUP_FRONTEND\n    description = \"Reglas para el frontend\"\n    }\n\n    # Creamos las reglas para el grupo de seguridad \"frontend-sg\"\n    resource \"aws_security_group_rule\" \"frontend_ingress\" {\n    count             = 5\n    security_group_id = aws_security_group.frontend.id\n    type              = \"ingress\"\n    from_port         = [22, 2049, 80, 443, 3306][count.index]\n    to_port           = [22, 2049, 80, 443, 3306][count.index]\n    protocol          = \"tcp\"\n    cidr_blocks       = [\"0.0.0.0/0\"]\n    }\n\n    # Creamos el grupo de seguridad del backend\n    resource \"aws_security_group\" \"backend\" {\n    name        = var.SECURITY_GROUP_BACKEND\n    description = \"Reglas para el backend\"\n    }\n\n    # Creamos las reglas para el grupo de seguridad \"backend-sg\"\n    resource \"aws_security_group_rule\" \"backend_ingress\" {\n    count             = 2\n    security_group_id = aws_security_group.backend.id\n    type              = \"ingress\"\n    from_port         = [22, 3306][count.index]\n    to_port           = [22, 3306][count.index]\n    protocol          = \"tcp\"\n    cidr_blocks       = [\"0.0.0.0/0\"]\n    }\n\n    # Creamos el grupo de seguridad del balanceador de carga\n    resource \"aws_security_group\" \"loadbalancer\" {\n    name        = var.SECURITY_GROUP_LOADBALANCER\n    description = \"Reglas para el balanceador de carga\"\n    }\n\n    # Creamos las reglas de entrada para el grupo de seguridad \"loadbalancer-sg\"\n    resource \"aws_security_group_rule\" \"loadbalancer_ingress\" {\n    count             = 5\n    security_group_id = aws_security_group.loadbalancer.id\n    type              = \"ingress\"\n    from_port         = [22, 3306, 80, 443, 2049][count.index]\n    to_port           = [22, 3306, 80, 443, 2049][count.index]\n    protocol          = \"tcp\"\n    cidr_blocks       = [\"0.0.0.0/0\"]\n    }\n\n    # Creamos el grupo de seguridad para el nfs server\n    resource \"aws_security_group\" \"nfs\" {\n    name        = var.SECURITY_GROUP_NFS\n    description = \"Reglas para el servidor NFS\"\n    }\n\n    # Creamos las reglas de entrada para el grupo de seguridad \"nfs-sg\"\n    resource \"aws_security_group_rule\" \"nfs_ingress\" {\n    count             = 2\n    security_group_id = aws_security_group.nfs.id\n    type              = \"ingress\"\n    from_port         = [22, 2049][count.index]\n    to_port           = [22, 2049][count.index]\n    protocol          = \"tcp\"\n    cidr_blocks       = [\"0.0.0.0/0\"]\n    }\n\n    # Creamos las instancias EC2 para los frontend 1 y frontend 2\n    resource \"aws_instance\" \"frontend\" {\n    count           = 2\n    ami             = var.ami_id\n    instance_type   = var.instance_type\n    key_name        = var.key_name\n    security_groups = [aws_security_group.frontend.name]\n\n    tags = {\n        Name = \"frontend-${count.index + 1}\"\n    }\n    }\n\n    # Creamos una instancia para el backend\n    resource \"aws_instance\" \"backend\" {\n    ami             = var.ami_id\n    instance_type   = var.instance_type\n    key_name        = var.key_name\n    security_groups = [aws_security_group.backend.name]\n\n    tags = {\n        Name = \"backend\"\n    }\n    }\n\n    # Creamos una instancia para el balanceador de carga\n    resource \"aws_instance\" \"loadbalancer\" {\n    ami             = var.ami_id\n    instance_type   = var.instance_type\n    key_name        = var.key_name\n    security_groups = [aws_security_group.loadbalancer.name]\n\n    tags = {\n        Name = \"loadbalancer\"\n    }\n    }\n\n    # Creamos una instancia para el NFS Server\n    resource \"aws_instance\" \"nfs\" {\n    ami             = var.ami_id\n    instance_type   = var.instance_type\n    key_name        = var.key_name\n    security_groups = [aws_security_group.nfs.name]\n\n    tags = {\n        Name = \"nfs\"\n    }\n    }\n\n    # Asociamos dos IPs el\u00e1sticas a las m\u00e1quinas frontend 1 y 2\n    resource \"aws_eip\" \"frontend\" {\n    count    = 2\n    instance = aws_instance.frontend[count.index].id\n    }\n\n    # Asociamos la IP el\u00e1stica a la instancia backend\n    resource \"aws_eip\" \"backend\" {\n    instance = aws_instance.backend.id\n    }\n\n    # Asociamos la IP el\u00e1stica a la instancia loadbalancer\n    resource \"aws_eip\" \"loadbalancer\" {\n    instance = aws_instance.loadbalancer.id\n    }\n\n    # Asignamos la IP el\u00e1stica a la instancia NFS Server\n    resource \"aws_eip\" \"nfs\" {\n    instance = aws_instance.nfs.id\n    }\n\n\n</code></pre>"},{"location":"practica4.5/#archivo-de-variables","title":"Archivo de variables","text":"<p>En este archivo, definiremos los valores de las variables del script de automatizaci\u00f3n</p> <pre><code>\n    variable \"region\" {\n    description = \"Regi\u00f3n de AWS donde creamos la instancia\"\n    type        = string\n    default     = \"us-east-1\"\n    }\n\n    variable \"allowed_ingress_ports\" {\n    description = \"Puertos de entrada del grupo de seguridad\"\n    type        = list(number)\n    default     = [22, 80, 443]\n    }\n\n    variable \"ami_id\" {\n    description = \"Identificador de la AMI\"\n    type        = string\n    default     = \"ami-00874d747dde814fa\"\n    }\n\n    variable \"instance_type\" {\n    description = \"Tipo de instancia\"\n    type        = string\n    default     = \"t2.small\"\n    }\n\n    variable \"key_name\" {\n    description = \"Nombre de la clave p\u00fablica\"\n    type        = string\n    default     = \"vockey\"\n    }\n\n    variable \"SECURITY_GROUP_FRONTEND\" {\n    description = \"Nombre del grupo de seguridad para el frontend\"\n    type        = string\n    default     = \"sg_frontend\" \n    }\n\n    variable \"SECURITY_GROUP_BACKEND\" {\n    description = \"Nombre del grupo de seguridad para el backend\"\n    type        = string\n    default     = \"sg_backend\"\n    }\n\n    variable \"SECURITY_GROUP_LOADBALANCER\" {\n    description = \"Nombre del grupo de seguridad para el balanceador de carga\"\n    type        = string\n    default     = \"sg_loadbalancer\"\n    }\n\n    variable \"SECURITY_GROUP_NFS\" {\n    description = \"Nombre del grupo de seguridad para el servidor NFS\"\n    type        = string\n    default     = \"sg_nfs\"\n    }\n\n</code></pre>"},{"location":"practica4.5/#archivo-de-salida","title":"Archivo de salida","text":"<p>Este archivo servir\u00e1 para definir y mostrar los valores de salida desopu\u00e9s de que la InfraEstructura se haya creado.</p> <pre><code>\n    # Mostramos las IPs el\u00e1sticas de las instancias frontend\n    output \"frontend_elastic_ips\" {\n    value = [for i in aws_eip.frontend : i.public_ip]\n    }\n\n    # Mostramos la IP el\u00e1stica del backend\n    output \"backend_elastic_ip\" {\n    value = aws_eip.backend.public_ip\n    }\n\n    # Mostramos la IP el\u00e1stica del loadbalancer\n    output \"loadbalancer_elastic_ip\" {\n    value = aws_eip.loadbalancer.public_ip\n    }\n\n    # Mostramos la IP el\u00e1stica del NFS_Server\n    output \"nfs_elastic_ip\" {\n    value = aws_eip.nfs.public_ip\n    }\n\n</code></pre>"},{"location":"practica4.5/#prueba-de-funcionamiento","title":"Prueba de Funcionamiento","text":"<p>Tras documentar los comandos de creaci\u00f3n, vamos a la prueba de la ejecuci\u00f3n.</p> <p>Nota: Al ser una salida larga, mostraremos captura del principio y del final de la ejecuci\u00f3n.</p> <p></p> <p></p> <p>Ahora, nos dirigimos al panel de AWS y comprobamos que se han creado los recursos de forma correcta.</p> <p></p> <p></p> <p></p> <p>Tras comprobar que se han creado correctamente las m\u00e1quinas y dem\u00e1s, procederemos a su borrado. Para proceder con su borrado, lo realizaremos con el comando:</p> <pre><code>terraform destroy -auto-approve\n</code></pre> <p>Este comando es el comando de borrado gen\u00e9rico de Terraform, d\u00f3nde con la opci\u00f3n \"-auto-approve\", le indicamos que todos los mensajes de confirmaci\u00f3n, sean aceptados autom\u00e1ticamente.</p> <p>Explicado el comando, procedemos a su ejecuci\u00f3n.</p> <p></p>"},{"location":"practica4.5/#prueba-de-funcionamiento_1","title":"Prueba de Funcionamiento","text":"<p>Para comprobar de que las instancias se han borrado eficazmente, IPs el\u00e1sticas y grupos de seguridad, nos dirigimos al panel de AWS:</p> <p></p> <p>Procedemos a comprobar la elimninaci\u00f3n de las IPs el\u00e1sticas as\u00ed c\u00f3mo grupos de seguridad.</p> <p></p> <p>Y por \u00faltimo, comprobamos el borrado efectivo de los grupos de seguridad.</p> <p></p>"},{"location":"practica5.4/","title":"Practica-IAW-5.4: Dockerizar una web est\u00e1tica y publicarla en Docker Hub","text":""},{"location":"practica5.4/#objetivo-de-la-practica","title":"Objetivo de la Pr\u00e1ctica","text":"<p>El objetivo de la pr\u00e1ctica ser\u00e1 crear un archivo \"DockerFile\" con Nginx para generar una imagen Docker que contenga una aplicaci\u00f3n web est\u00e1tica. Desplegaremos dicha imagen en una m\u00e1quina de EC2 con Docker y Docker Compose.</p>"},{"location":"practica5.4/#estructura-de-la-practica","title":"Estructura de la Pr\u00e1ctica","text":""},{"location":"practica5.4/#desarrollo-de-la-practica","title":"Desarrollo de la pr\u00e1ctica","text":"<ul> <li><code>Dockerfile</code>: Este archivo crea una imagen de Docker basada en Nginx y configura un entorno para servir la aplicaci\u00f3n web 2047, tras citar el contenido del archivo, iremos explicando la funci\u00f3n de cada l\u00ednea.</li> </ul> <p>Contenido del archivo: </p> <pre><code>        FROM nginx:latest\n\n        LABEL AUTHOR=\"JUAN\"\n        LABEL DESCRIPTION=\"2048\"\n\n        RUN apt-get update \\\n            &amp;&amp; apt-get install -y git \\\n            &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n        RUN git clone https://github.com/josejuansanchez/2048.git /app \\\n            &amp;&amp; cp -R /app/* /usr/share/nginx/html/\n\n        EXPOSE 80\n\n        CMD [\"nginx\", \"-g\", \"daemon off;\"]\n\n</code></pre> <p>En primer lugar, especificaremos que usaremos la imagen de docker basada en Nginx.</p> <p>En segundo lugar, a\u00f1adiremos metadatos indicando el autor y la descripci\u00f3n, en el caso de autor ser\u00e1 mi nombre, y en el caso de Descripci\u00f3n, le indicaremos el contenido de la imagen.</p> <p>Ejecutaremos alg\u00fan comando de actualizaci\u00f3n, instalaremos git ya que es necesario para clonar el repositorio de la aplicaci\u00f3n, y limpiaremos archivos de instalaci\u00f3n para reducir el tama\u00f1o de la imagen.</p> <p>En siguiente lugar, clonaremos el respositorio de la aplicaci\u00f3n web y copiaremos los archivos al directorio de Nginx.</p> <p>Indicaremos que el contenedor usar\u00e1 el puerto 80 y por \u00faltimo, ejecutaremos Nginx.</p> <p>Tras explicar la funci\u00f3n del primer archivo, explicaremos la funci\u00f3n del archivo \"publish-to-docker-hub.yml\" alojado en el directorio \".github/workflows\".</p> <ul> <li><code>publish-to-docker-hub.yml</code>: Este archivo es un workflow de Github Actions que automatiza la construcci\u00f3n y publicaci\u00f3n de una imagen Docker Hub cada cez que se realiza un push a la rama main.</li> </ul> <pre><code>        name: Publish image to Docker Hub\n\n    # This workflow uses actions that are not certified by GitHub.\n    # They are provided by a third-party and are governed by\n    # separate terms of service, privacy policy, and support\n    # documentation.\n\n    on:\n    push:\n        branches: [ \"main\" ]\n        # Publish semver tags as releases.\n        tags: [ 'v*.*.*' ]\n    workflow_dispatch:\n\n    env:\n    # Use docker.io for Docker Hub if empty\n    REGISTRY: docker.io\n    # github.repository as &lt;account&gt;/&lt;repo&gt;\n    #IMAGE_NAME: ${{ github.repository }}\n    IMAGE_NAME: 2048\n    IMAGE_TAG: latest\n\n    jobs:\n    build:\n\n        runs-on: ubuntu-latest\n        permissions:\n        contents: read\n        packages: write\n\n        steps:\n        - name: Checkout repository\n            uses: actions/checkout@v3\n\n        # Set up BuildKit Docker container builder to be able to build\n        # multi-platform images and export cache\n        # https://github.com/docker/setup-buildx-action\n        - name: Set up Docker Buildx\n            uses: docker/setup-buildx-action@f95db51fddba0c2d1ec667646a06c2ce06100226 # v3.0.0\n\n        # Login against a Docker registry except on PR\n        # https://github.com/docker/login-action\n        - name: Log into registry ${{ env.REGISTRY }}\n            uses: docker/login-action@343f7c4344506bcbf9b4de18042ae17996df046d # v3.0.0\n            with:\n            registry: ${{ env.REGISTRY }}\n            username: ${{ secrets.DOCKERHUB_USERNAME }}\n            password: ${{ secrets.DOCKERHUB_TOKEN }}\n\n        # This action can be used to check the content of the variables\n        - name: Debug\n            run: |\n            echo \"github.repository: ${{ github.repository }}\"\n            echo \"env.REGISTRY: ${{ env.REGISTRY }}\"\n            echo \"github.sha: ${{ github.sha }}\"\n            echo \"env.IMAGE_NAME: ${{ env.IMAGE_NAME }}\"\n\n        # Build and push Docker image with Buildx (don't push on PR)\n        # https://github.com/docker/build-push-action\n        - name: Build and push Docker image\n            id: build-and-push\n            uses: docker/build-push-action@0565240e2d4ab88bba5387d719585280857ece09 # v5.0.0\n            with:\n            context: .\n            push: ${{ github.event_name != 'pull_request' }}\n            tags: ${{ env.REGISTRY }}/${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}\n            cache-from: type=gha\n            cache-to: type=gha,mode=max          \n</code></pre> <p>En primer lugar, definiremos el nombre del workflow c\u00f3mo \"Publish image to Docker Hub\", este nombre ser\u00e1 visible en la pesta\u00f1a \"Actions\" de Github.</p> <p>Se ejecutar\u00e1 cuando se hace un push a main o cu\u00e1ndo se cree un tag con el formato \"vX.Y.Z\". Permitiendo tambi\u00e9n ejecutar el workflow manualmente desde Github Actions.</p> <p>Tendremos una secci\u00f3n de variables de entorno, d\u00f3nde usar\u00e1 Docker Hub c\u00f3mo registro de im\u00e1genes, le indicaremos el nombre de la imagen Docker que se construir\u00e1 y le asignaremos la etiqueta \"latest\" a la imagen.</p> <p>Definiremos el job llamado build, d\u00f3nde especificamos que se ejecuta en una m\u00e1quina virtual de ubuntu y tendr\u00e1 permisos de solo lectura para el c\u00f3digo fuente y permisos de escritura para subir la imagen Docker.</p> <p>En siguiente lugar, clonaremos el respositorio usando la acci\u00f3n \"checkout@v3\".</p> <p>El siguiente paso ser\u00e1 configurar Docker Buildx, d\u00f3nde lo habilitaremos para poder construir im\u00e1genes optimizadas y multiplataforma.</p> <p>Lo siguiente ser\u00e1 iniciar sesi\u00f3n en Docker Hub, usando las credenciales almacenadas en Secrets de Github, en este caso tendremos los secrets \"DOCKERHUB_TOKEN\" y \"DOCKERHUB_USERNAME\", d\u00f3nde tendremos un token de Docker Hub de forma que no haya que introducir cada vez que realizemos alguna operaci\u00f3n las credenciales de DockerHub.</p> <p>Cabe decir que la secci\u00f3n \"Secrets\" es una forma segura de manejar las credenciales en GitHub Actions.</p> <p>Tras explicar el apartado anterior, seguiremos explicando, en este caso la secci\u00f3n Debug, signific\u00e1ndo esto que imprime en la consola algunas variables para verficar que tienen los valores correctos.</p> <p>Por \u00faltimo lugar, construiremos y subiremos la imagen a Docker Hub.</p> <p>Tras explicar todas las l\u00edneas del archivo, visualizaremos el Token Creado de DockerHub para posteriormente visualizarlo en Github Actions Secret.</p> <p></p> <p></p>"},{"location":"practica5.4/#comandos-a-ejecutar-en-la-maquina","title":"Comandos a ejecutar en la m\u00e1quina","text":"<p>Una vez llegados a este punto, redactaremos los comandos usados para el desarrollo del proceso de la publicaci\u00f3n de nuestra imagen en Docker Hub.</p> <p>En primer lugar, usaremos el comando \"docker build -t juangarcia24/2048 .\" para crear la imagen de Docker a partir del archivo explicado anteriormente Dockerfile.</p> <p>Ahora, con el comando docker tag juangarcia24/2048 juangarcia24/2048:1.0\" le a\u00f1adiremos una etiqueta a la image, en este caso siendo \"1.0\".</p> <p>Acto seguido, con el comando \"docker-compose\" lanzaremos el docker.</p> <p></p> <p>En siguiente lugar, para comprobar que la imagen se ha creado correctamente ejecutaremos el comando \"docker images\" para listar las imagenes guardadas en nuestro sistema.</p> <p></p> <p>Realizado lo anterior, tendremos que iniciar sesi\u00f3n con el usuario y contrase\u00f1a de DockerHub con el comando \"docker login -u juangarcia24\". Pedir\u00e1 la introducci\u00f3n de una contrse\u00f1a, en este caso, la contrase\u00f1a a introducir ser\u00e1 el token de DockerHub creado anteriormente.</p> <p></p> <p>En siguiente lugar, procedemos a realizar un push para poder publicar la imagen, lo realizaremos con las dos etiquetas creadas:</p> <p></p> <p>Si pulsamos sobre los detalles del commit, figura que se ha publicado correctamente en Docker Hub.</p> <p></p> <p>Por \u00faltimo, probaremos a dirigirnos a la p\u00e1gina de Docker Hub para comprobar la existencia de nuestra imagen creada y sincronizada.</p> <p></p>"},{"location":"practica5.4/#comprobacion-de-funcionamiento","title":"Comprobaci\u00f3n de funcionamiento","text":"<p>Llegados a este punto de la pr\u00e1ctica, comprobaremos que se ha implantado correctamente la aplicaci\u00f3n web, por lo que, en primer lugar, la arrancamos con el siguiente comando:</p> <pre><code>    docker run -d -p 80:80 2048\n</code></pre> <p></p> <p>Ahora, introducimos en nuestro navegador la IP el\u00e1stica de la m\u00e1quina y comprobamos que carga la aplicaci\u00f3n Web.</p> <p></p>"}]}